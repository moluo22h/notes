# Java代理模式简介

代理模式是一种常见的设计模式，它允许我们通过创建一个代理对象来控制对真实对象的访问。在Java中，代理模式可以通过接口实现或者继承实现。

## 代理模式的结构

代理模式包含以下几个角色：

1. 抽象主题（Subject）：定义了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题。
2. 真实主题（Real Subject）：定义了代理角色所代表的真实对象。
3. 代理主题（Proxy Subject）：持有对真实主题的引用，可以控制对真实主题的访问，并在需要的时候创建或删除真实主题对象。

## Java代理模式的实现方式

在Java中，我们可以通过以下三种方式来实现代理模式：

### 静态代理

静态代理是指在编译时就已经确定代理类的方式。在静态代理中，代理类和真实类实现相同的接口或者继承相同的父类。代理类持有真实类的引用，并在调用真实类的方法前后进行一些额外的操作。详见[Java静态代理](11.2.Java静态代理)

优点：

- 简单易懂，实现起来相对容易。
- 可以在编译时就确定代理类，对代理对象的访问进行控制。

缺点：

- 需要为每个真实类编写一个代理类，导致类的数量增加。

### JDK动态代理

JDK动态代理是指在运行时动态生成代理对象的方式。在JDK动态代理中，代理类实现了`InvocationHandler`接口，并持有真实类的引用。在调用代理类的方法时，通过**反射机制**调用真实类的方法，并在方法的前后进行一些额外的操作。详见[JDK动态代理](11.3.JDK动态代理)

优点：

- 无需为每个真实类编写代理类，减少了类的数量。

缺点：

- 只能代理接口，无法代理没有实现接口的类。
- 生成的代理类性能相对较低。

### CGLib动态代理

CGLib动态代理是指在运行时通过**字节码技术**生成代理类的方式。在CGLib动态代理中，代理类继承了真实类，并重写了真实类的方法。在调用代理类的方法时，通过调用父类的方法来间接调用真实类的方法，并在方法的前后进行一些额外的操作。详见[CGLib动态代理](11.4.CGLib动态代理)

优点：

- 可以代理没有实现接口的类。
- 生成的代理类相对较快，性能较高。

缺点：

- 由于使用了继承，无法代理final类和final方法。
- 需要依赖第三方jar包

## Java代理模式对比总结

- 静态代理适用于简单的场景，代理类和真实类在编译时就确定，易于理解和实现。
- JDK动态代理适用于需要代理接口的场景，无需为每个真实类编写代理类，但性能相对较低。
- CGLib动态代理适用于代理没有实现接口的类的场景，生成的代理类性能较高，但无法代理final类和final方法。

根据具体的需求和场景，我们可以选择适合的代理方式来实现对真实对象的代理控制。

## 代理模式的应用场景

代理模式在很多场景中都有应用，常见的应用场景包括：

- 日志记录：在方法调用前后记录日志信息。
- 安全控制：在方法调用前进行权限校验。
- 性能监控：统计方法的执行时间等性能指标。

代理模式可以方便地对目标类进行功能增强，同时也可以对目标类进行保护，使得客户端无需关心目标类的具体实现细节。

以上就是Java代理模式的简介，希望对你理解代理模式有所帮助！