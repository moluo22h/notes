# 线程安全

如果一个对象可以安全的被多个线程使用，那么它就是线程安全的。

我们这里讨论的线程安全，就限定于多个线程之间存在共享数据访问这个前提，如果一段代码根本不会与其他线程共享数据，那么这段代码一定是线程安全的。

## 共享数据按安全程度分类

- **不可变**：不可变的对象一定是线程安全的。
- **绝对线程安全**：对于绝对线程安全的对象，不管运行环境如何，调用者都不需要任何的额外同步措施。
- **相对线程安全**：一个对象相对线程安全，可以保证对象单独的操作是线程安全的，但是对于一些特定顺序的连续调用，可能需要额外的同步手段保证调用的正确性。
- **线程兼容**：线程兼容的对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段保证对象在并发环境中可以安全的使用。
- **线程对立**：线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

## 线程安全的实现方式

- **互斥同步**：互斥同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用

  实现互斥同步的手段包括synchronized关键字和java.util.concurrent包中的重入锁（ReentrantLock）。相比synchronized，ReentrantLock具有等待可中断、可实现公平锁，以及锁可以绑定多个条件这样的高级功能，若需要这三个功能请使用ReentrantLock。

- **非阻塞同步**：互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种锁也称为阻塞同步。而先进行操作，如果没用其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采取其他的补偿措施，这个同步操作被称为非阻塞同步，非阻塞同步不需要把线程挂起。

- **无同步方案**：有的方法本来就不涉及共享数据，那它自然无须任何同步措施去保证安全性，因此用一些代码天生就是线程安全的。这个天生就线程安全的代码包括：

  - 可重入代码：可重入代码在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。

  - 线程本地存储：线程本地存储保证共享数据的代码在同一个线程中执行。

