## 虚拟机字节码执行引擎

代码被编译为字节码存储在class文件中，经过类加载读取类的二进制字节流形成可以被虚拟机直接使用的Java类型。那接下去便是**方法调用**和**方法执行**。

- **方法调用**并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程

- **方法执行**才涉及方法内部的具体运行过程，在本文中，我们将与图示的形式为大家讲解

不过在此之前，我们需要先了解一个概念 - **栈帧**

每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。那栈帧是什么呢？

##  运行时栈帧结构

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的**局部变量表**、**操作数栈**、**动态连接**和**方法返回地址**等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。栈帧的概念结构如下图：

![栈帧的概念结构](https://res.weread.qq.com/wrepub/epub_603120_409)

接下来详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的作用和数据结构。

### 局部变量表

局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量

### 操作数栈

操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out, LIFO）栈。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）

我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为**静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为**动态连接**。

### 方法返回地址

方法退出之后，都需要返回到方法被调用的位置

### 附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。

## 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。

说句实话，“方法调用”一词很容易造成误解，翻译成“方法查找”或许会好一些。

方法调用是如何进行的，我们不展开讲，大家只要知道在方法执行前有方法调用这个过程即可，想深入了解的同学可查阅《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 》

## 方法执行

方法执行，我们将以图示方式进行讲解。我们准备了一段四则运算的Java代码，看看在虚拟机中实际是如何执行的

```java
public int calc() {
       int a = 100;
       int b = 200;
       int c = 300;
       return (a + b) * c;
}
```

从Java语言的角度来看，这段代码没有任何解释的必要，可以直接使用javap命令看看它的字节码指令，如下所示：

```yaml
public int calc();
  Code:
   Stack=2, Locals=4, Args_size=1
   0:   bipush 100
   2:   istore_1
   3:   sipush 200
   6:   istore_2
   7:   sipush 300
   10: istore_3
   11: iload_1
   12: iload_2
   13: iadd
   14: iload_3
   15: imul
   16: ireturn
}
```

其字节码指令的执行过程中如下，在其中我们可以看到操作数栈和局部变量表的变化情况

![](https://res.weread.qq.com/wrepub/epub_603120_437)

![](https://res.weread.qq.com/wrepub/epub_603120_438)

![](https://res.weread.qq.com/wrepub/epub_603120_439)

![](https://res.weread.qq.com/wrepub/epub_603120_440)

![](https://res.weread.qq.com/wrepub/epub_603120_441)

![](https://res.weread.qq.com/wrepub/epub_603120_442)

![](https://res.weread.qq.com/wrepub/epub_603120_443)

到此，你应该已经了解了一个方法执行的全过程。

> 注意：上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述……更准确地说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化

## 参考文档

- 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 