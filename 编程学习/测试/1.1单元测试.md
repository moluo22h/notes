# 单元测试

## 单元测试范围

1.接口功能性测试: 接口功能的正确性,即保证接口能够被正常调用，并输出有效数据!

* 是否被顺利调用

* 参数是否符合预期

2.局部数据结构测试：保证数据结构的正确性

* 变量是否有初始值或在某场景下是否有默认值 

* 变量是否溢出

3.边界条件测试：测试

* 变量无赋值(null)
*  变量是数值或字符
* 主要边界：最大值，最小值，无穷大
* 溢出边界：在边界外面取值+/-1
* 临近边界：在边界值之内取值+/-1
* 字符串的边界，引用 "变量字符"的边界
* 字符串的设置，空字符串
* 字符串的应用长度测试
* 空白集合
* 目标集合的类型和应用边界
* 集合的次序
* 变量是规律的，测试无穷大的极限，无穷小的极限

4.所有独立代码测试：保证每一句代码，所有分支都测试完成，主要包括代码覆盖率，异常处理通路测试

* 语句覆盖率：每个语句都执行到了
* 判定覆盖率：每个分支都执行到了
*  条件覆盖率：每个条件都返回布尔
*  路径覆盖率：每个路径都覆盖到了

5.异常模块测试，后续处理模块测试:是否包闭当前异常或者对异常形成消化,是否影响结果!



## 单元测试规范

1.[强制] 好的单元测试必须遵守AIR原则。

    说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 
    Automatic: 自动化
    Independent: 独立性
    Repeatable: 可重复

2.[强制] 单元测试应该是全自动执行的，并且非交互式的。

    测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。
    输出结果需要人工检查的测试不是一个好的单元测试。
    单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。

3.[强制] 保持单元测试的独立性。

    为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。
    反例：method2需要依赖method1的执行，将method1的执行结果作为method2的输入。

4.[强制] 单元测试是可以重复执行的，不能受到外界环境的影响。

    说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。
    正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。

5.[强制] 对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。

    说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。

6.[强制] 核心业务、核心应用、核心模块的增量代码确保单元测试通过。

    新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。

7.[强制] 单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。

    源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。

8.[强制] 单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%.

    说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。

9.[推荐] 编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。

    Border: 边界值测试，包括循环、 特殊取，边界值测试包括循环、 特殊取特
    Correct: 正确的输入，并得到预期结果。
    Design: 与设计文档相结合， 来编写单元测试
    Error: 强制错误信息输入(如:非法数据、异常流程、非业务允许输入等)，并得到预期的结果。

10.[推荐] 对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。

    反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。

11.[推荐] 和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。

    正例：在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。

12.[推荐] 对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。

13.[推荐] 在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。

14.[推荐] 单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。

15.[参考] 为了更方便地进行单元测试，业务代码应避免以下情况：

    构造方法中做的事情过多。
    存在过多的全局 变量 和静态方法。
    存在过多的外部依赖。
    说明： 多层条件语句建议使用卫、策略模式状态等方重构。

16.[参考] 不要对单元测试存在如下误解：

    那是测试同学干的事情 ，凡是本文内容都与开发同学强相关的。
    单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常否是强相关。
    单元测试代码不需要维护。 一年半载后，那么几乎处于废弃状态
    单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。

## 单元测试问题

没有返回值的方法如何判断结果？

通过测试方法调用次数

```java
 Mockito.doAnswer(new Answer<Object>() {
            public Object answer(InvocationOnMock invocation) {
                Object[] args = invocation.getArguments();
                return "called with arguments: " + args;
            }	
        }).when(对象).方法名();
```



一个方法中包含多个功能如何处理？



同类方法间调用如何Mock数据？或者说如何隔离本类方法

不mock了





测试异常？

1.try…fail...catch…

2.@Test(expected=xxx) 

3.ExpectedException Rule

​    

单元测试的细粒度到什么程度？

级别：

TDD的最佳实践是每个test function只有一个assert

同一个test function里使用多个assert来对不同的方面进行测试





私有方法是否需要测试？

## 优化

输入数据Mock

断言

keycloak 用户模拟



## 参考文档

[测试整合之王Unitils（单元测试系列）](https://blog.csdn.net/achuo/article/details/47726241)

[单元测试时如果期望值是抛出异常的处理方法](https://blog.csdn.net/zhuwenliangzhuyeqing/article/details/60769256)



